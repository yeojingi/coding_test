## PlainKnapsack_12865.py
-------

220814  
동적 계획법 공부  

역시 점화식 개념처럼 접근 했다.  
잘 떠오르지 않아서 생각을 좀 했다.  

처음에 동적 계획법을 적용하려고 했을 때 들었던 고민이 있는데,  
메모이제이션 배열 m이 있고, 이번 단계에서 (w)eight, (v)alue인 짐을 넣으려고 하는데,  
m[i-w] 을 그대로 적용해도 되는 걸까?  
같은 m[i-w]이더라도 무게가 얼마나 남았는지에 따라 다르게 취급해야 하는 것 아닌지에 대한 의문이 들었다.  
그런데 이것은 m[i-w-??]이란 배열에 이미 반영이 되어 있는 정보였다.  
의문을 명확하게 하는 것이 좋은 것 같다.  

그럼에도 불구하고 한번 실패를 했는데 그 이유는 메모이제이션 배열을, 이전 단계의 배열을 안 쓰고 지금 단계의 배열을 썼다.  
만약에 무게가 1이고 가치가 10인 애가 있다면,  
[10, 20, 30, 40, ...] 계속해서 늘어난다.  
언어로 명확하게 하지 않은 부분에서부터 이런 실수가 다시 나타나는 것 같다.

### Takeaways
알고리즘을 짤 때 드는 의문을 언어로 명확히 하자  
그리고 실력이 는다는 것은 하나의 인간 언어 문장으로 나온 생각이 쉽게 다뤄지는 것 같다.  
그러니까, 메모이제이션 배열을 만들자라는 생각이 들 때, 이전 배열을 써야한다는 것까지 자연스럽게 다뤄지지 않으니까 실수가 발생한다.  
결국 linking&chunking을 통해 숙련되는 것이 알고리즘에도 적용되는 것이다.  

### 의문점

## RGBDistance_1149.py
-------

220813  
동적 계획법 공부하려고 풀었다.

하버드에 나온 유튜브 [링크](https://www.youtube.com/watch?v=0y5UkZc-C8Y&t=1049s) 에서 동적계획법은 룩업테이블 알고리즘이라고 해서 동적 계획법 풀 때 룩업테이블을 만드려고 노력했는데 그게 아닌 것 같다.  
수학적 귀납법/ 점화식으로 접근하는 게 더 맞는 듯.  
이 문제는 점화식 적으로 접근했다.  
잘 풀린 듯.  
완전 탐색으로 풀려고 하다가 동적계획법적 방법을 찾았다.  
동적 계획법은 처음 풀 때 동적계획법으로 풀어야겠다는 계획이 잘 나오지 않는다고 POCU 강의에서 그랬는데, 이번에 문제 풀 때 딱 그랬다.

### 파이썬 팁
* arr = list(map(int, s.split(" ")))  
 -> 문자열을 숫자 배열로 만들 때 쓸 수 있다.  
 -> int라는 함수를 s.split(" ")라는 iterable에 적용한 다음에 이것을 list화 해준 것이다.  
 -> return 결과가 map object 여서 배열처럼 쓰려면 list를 해줘야 하는 것이다  
 
 ### Takeaways
 꼭 여기서가 아니더라도, 배열에 따라 뭔가 함수를 적용해야할 때 쓸 수 있겠다.  
 자바스크립트로 치면 map, forEach를 통한 컴퓨팅에 썼던 사고가 필요할 때 저 함수를 쓰면 될 듯  

### 의문점
완전 탐색보다 검색량이 줄어든 지는 모르겠다.  